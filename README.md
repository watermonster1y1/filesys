实验一
=======
徐世显，赵薪宇，孔德嘉，张天乐，卢彦良组队；
选题：在线文档管理系统

面向企业用户，研制开发一套文档管理系统，实现企业文档的存储、分类、维护、检索、授权等过程的全面管理。为用户主要提供如下功能：
1）登陆：用户通过浏览器登陆到系统，输入用户名和密码，登陆到系统，看到本用户所能看到的各类信息，包括文档分类树、文档的基本信息等。
2）人员组织角色管理与授权管理：创建和维护企业的人员、组织和角色，人员具有登陆名、名称、密码、邮件、手机等一些基本的属性，人员从属与一个或多个组织，具有一个或多个角色，组织间具有层次关系。提供文档按照人员与角色两种方式的授权模式。
3）文档分类管理：用户可以增删改文档的分类，文档分类间可以建立层次关系。
4）文档维护：用户可以增删改文档，文档包括基本的描述信息（如文档编号、文档名、文档创建时间、创建人、大小等）及文档对应的文件列表。
5）文档检索：用户可以方便的按照文档的名称、编号、创建时间、创建人等信息进行检索。

实验七
=======
《掌握需求过程(第3版) 》附录A和国标SRS的模板对比
-------------
Volere模板来源于国际标准化工程实践，结构非常详尽且模块划分细致，共包含27大项内容，进一步细分为小项，详细定义客户、顾客、维护人员、假想用户，并明确参与度与优先级， 覆盖全生命周期（开发→迁移→迭代），适合用于需求不明确、干系人复杂的大中型项目。它强调需求的分类与完整性，从业务背景、利益相关者、环境约束到可用性、性能、安全、文化与法律等，几乎覆盖了软件需求的所有方面。Volere模板中的一大特色是对“观感需求”“人性化需求”“文化需求”“开放式问题”等通常被忽略部分的专门考虑，反映出其更注重用户体验和系统长期可持续性。此外，它的“任务”和“迁移”“风险”“后续版本”等内容也为整个项目的生命周期管理提供良好支持。总的来说，Volere模板更注重系统思维、多干系人协作和面向产品全生命周期的需求捕获。


SRS（软件需求规格说明）模板更符合我国工程实施中实际项目文档管理的习惯，结构更为简洁实用，适用于需求较明确、实施周期较短的工程项目。它主要分为范围、引用文件、需求、合格性规定等大项，核心内容集中在“3.3需求规格”部分，包括总体功能、子系统功能、外部接口、硬件和软件需求、故障处理、优先级等，便于开发团队直接对照实现。该模板突出了功能需求与系统接口实现，强调技术落地和开发可行性，特别是详细的“CSCI能力需求”和“用户界面”“接口”说明，使其在面向实现层的系统开发中具有较强的指导性。此外，它在保密性、性能、故障处理、算法等非功能性需求方面的说明也比较规范，便于测试验收时使用。



Volere模板更全面、细致、理论性强，强调对“问题空间”和“解决方案空间”的并重探索，适合需求不稳定或需要精细梳理场景的复杂项目。而国标SRS模板更注重“软件功能规格”的工程实现导向，偏向“解决方案”具体化和形式化表达，更契合中国本地项目管理和交付流程的需求。此外，Volere强调干系人分类、文化背景和开放式问题的记录，有助于长远迭代和用户参与；而SRS更聚焦当前系统的可实现性、接口设计和优先级排序，更利于软件开发过程中的模块划分和责任界定。因此，可以认为Volere适用于需求获取初期和需求动态变化的国际项目，而SRS更适合已有框架、周期明确的开发任务中作为标准化交付文档使用。

静态模型系统建模
------------

E-R图
![49294caf53a34fbf44405ece0332d4b7](https://github.com/user-attachments/assets/fbc08c25-88ee-44ac-8754-c8899cee4185)

UML图
![99db5eda4bbb0f4e4aae346115ea7412](https://github.com/user-attachments/assets/644112c3-05bf-4819-9609-63a446d1012d)
管理员关联：
    1对多发布公告
    1对多管理员工
    1对多上传文档

员工关联：
    多对多查看公告
    多对多下载文档

文档组成：
    1对多包含附件

核心属性：
   管理员：用户名、密码、角色
   员工：工号、姓名、性别、岗位
   文档：名称、类型
   公告：内容、发布时间
    附件：名称


实验九
========
UML
-------
用例图：用例图是需求可视化的核心工具，用于界定系统边界，识别主要用户角色，梳理系统功能单元，明确用户与系统交互关系。
       用例图主要元素分为三种：参与者、用例、关系
       关系分为四种：关联关系：描述了参与者与用例之间的通信。它表示某个参与者可以执行某个用例。
                    包含关系：表示一个用例的行为包含了另一个用例的行为。基础用例依赖于包含用例的执行结果。
                    扩展关系：表示一个用例可以扩展另一个用例的功能。扩展用例是可选的，只有在特定条件下才会执行。
                    泛化关系表示子用例继承父用例的行为和属性。



                    
类图：静态结构核心，类图是由类、接口等模型元素以及它们之间的关系构成的，用于描述系统的构成方式。类图定义系统中“有哪些对象”，它们“包含哪些属性和行为”，以及“彼此之间的关系”（继承、依赖、聚合、组合等）。具体图示可参照实验七。




活动图： 活动图描述的是对象活动的顺序关系以及所遵循的规则，着重表现的是系统的行为。
如下图登录过程：
![da820ab2330294795772bca3405caeb6](https://github.com/user-attachments/assets/7d5b654f-c960-40f0-a08d-e3d0a0838b46)

顺序图：用来表示用例中的行为顺序。当执行一个用例行为时，顺序图中的每条消息对应了一个类操作或状态机中引起转换的事件。顺序图展示对象之间的交互，这些交互是指在场景或用例的事件流中发生的。 顺序图属于动态建模。​顺序图的重点在消息序列上，也就是说，描述消息是如何在对象间发送和接收的。表示了对象之间传送消息的时间顺序。

                        

状态图：状态图显示了对象存在的各种状态，以及对象如何从一种状态转换到另一种状态。

组件图：组件图用于显示一组软件构建及它们之间的关系。

部署图：部署图由节点以及节点之间的关联关系构成，用于反映系统执行处理过程中系统资源元素的配置情况以及软件到这些资源元素的映射。

结合在线文档系统，不同阶段可以绘制不同的UML图
![5204723021786fc209d5061080578eaa](https://github.com/user-attachments/assets/b9646cc2-1136-4519-b996-d6a7352eb9f9)


常用逻辑及其在计算机学科中的应用
-----------
命题逻辑：使用命题变量（如 p、q）和逻辑联结词（如 ∧、∨、¬、→）。在文档系统管理中可以登录验证、菜单选项控制、异常处理与提示逻辑。
    示例应用：“若用户已登录且角色为管理员，则可以上传文档”      LoggedIn ∧ IsAdmin → CanUpload



谓词逻辑：引入量词（全称 ∀ 和存在 ∃），能表达关于对象及其属性的更精细陈述。能用于数据库查询语言（SQL的形式语义）；程序规范与验证；知识表示与推理；自动推理系统基础。
         在文档管理系统中可以用于查找搜索。


时序逻辑：引入时间维度，如未来必须满足 □p（always p）、存在性 ◇p（eventually p）；分为线性时序逻辑（LTL）和分支时序逻辑（CTL）。可用于文档生命周期控制和日志和安全行为检查。
如“任何文档上传请求，必须最终对应一个记录入库的操作    ”AG(UploadRequest → AF(DocumentStored))     结合模型检查工具（如NuSMV），可对状态转移流程进行自动验证，确保不会遗漏关键业务环节。

模态逻辑：在命题逻辑上引入“可能性”与“必然性”等模态运算，如 ◇p（可能）与 □p（必然）。可用于多角色系统设计、安全策略制定、用户视图隔离。如文档管理系统中用户和管理员。


形式逻辑在计算机科学中的应用贯穿系统建模、验证与程序正确性论证等多个关键领域。通过Hoare逻辑与一阶逻辑（FOL）表达程序的前置与后置条件，开发者可利用Z3、Isabelle等工具进行自动定理证明。模型检测方法借助时序逻辑与Kripke结构，可自动验证系统状态是否满足关键属性，广泛应用于嵌入式与通信协议的验证。自动定理证明利用自然演绎与分辨率技术，支持AI与形式化方法的逻辑推理。而类型系统中λ演算与逻辑之间的Curry-Howard同构使得程序可被视为定理，Coq、Agda等工具则使得逻辑化编程成为可能。




经典软件体系结构案例
-----------
D.L. Parnas 在这篇论文中首次明确提出“信息隐藏”（Information Hiding）原则，颠覆了当时普遍采用的以处理流程为导向的模块划分方式。他指出传统做法虽然直观，例如按输入、处理、输出阶段拆分模块，但存在高度耦合、重叠数据使用、设计决策暴露等问题。这种结构在设计初期看似清晰，然而在后期维护或需求变更时，会导致多个模块需要同时修改，增加了系统维护成本。Parnas提出，模块应围绕隐藏某种易变的设计决策来划分，系统才具有良好的可修改性、可理解性和可演化性。信息隐藏不只是一种编程技巧，而是架构设计的根本指导思想，直接影响了后来的面向对象设计、微服务架构等发展方向。


为验证其观点，Parnas采用了一个典型实例——“关键字在上下文中的索引系统”（KWIC）。他将该系统分别采用两种方式进行模块划分：一种是传统的按处理流程划分，另一种是按照信息隐藏原则重新组织。在传统方法中，模块如输入、循环移位、排序、输出等按执行顺序组织，但它们高度依赖公共数据结构，导致设计细节外泄。相比之下，信息隐藏方式将如“行存储”、“移位”、“排序”作为独立模块，每个模块暴露有限接口并封装其实现细节，使得模块间耦合显著减少，修改某个子系统不必波及他处。这一对比直观展现了信息隐藏方法在降低复杂性、增强可维护性方面的巨大优势。



论文不仅理论上提出信息隐藏，还总结出一系列针对模块划分的实践指导原则。首先，所有数据结构必须局限于内部模块，避免被外部调用者直接访问。其次，与某一类处理紧密相关的控制逻辑或调用顺序应放入统一模块内，以避免因接口变化造成传播性错误。再次，对于那些经常变化的需求特性，如字符排序方式、平台依赖格式或压缩算法等，都应设计为单独模块以便隔离。这种做法不仅有助于提升代码可维护性和复用性，也为未来系统升级和替换策略留出空间，从而增强系统的整体生命周期稳定性。



Parnas也承认，信息隐藏可能会带来一定的性能开销，特别是在模块间频繁调用或数据传输时，这种逻辑解耦可能不利于运行时效率。但他认为，设计上的清晰性与可维护性优先于局部性能的最大化。为了兼顾效率，他建议可使用低级实现手段如宏替换、过程内联、内存共用等，将接口设计与底层实现分离。这种折中策略也说明模块划分并非一刀切的结构选择，而是根据系统规模、团队协作、后期维护需求等多因素决定的架构层次设计问题。在大型系统中，合理的模块划分可以避免“技术债”，从长期角度来看，比单纯追求性能优化更具可持续性。



信息隐藏带来的另一个重要优势是：极大地提升了代码复用性和系统的多版本支持能力。Parnas在文中指出，通过恰当划分模块，不同系统可以共享底层核心逻辑，仅通过顶层控制策略的变更即可派生出新的产品版本。例如，解释器与编译器可以共用相同的语言解析模块，仅更换执行策略即可生成不同版本系统。这种结构性设计思维使得团队可以并行开发，隔离测试，也为后续客户定制化、平台适配提供了结构性支持。它还为后来软件工程中的组件化、插件式设计、服务分离等思想奠定了理论基础。



《On the Criteria To Be Used in Decomposing Systems into Modules》这篇论文被誉为软件体系结构设计的奠基之作之一，其核心思想“信息隐藏”已成为现代软件架构的基本原则。在当今复杂系统设计中，如微服务架构、DDD领域驱动设计、模块化单页应用等，无一不体现这一原则的深远影响。它使得系统设计从“代码组织”跃升为“演化策略”的层面。模块不仅是代码的容器，更是设计变更的防火墙。Parnas的思想教导我们：优秀的系统架构不是让所有部分完美运行，而是让变更尽可能局部，系统在未来依然能以最小成本快速响应变化。








实验十三
============
Factory Method
---------





Singleton
-----------





Strategy Pattern
-------------------





Template Method
---------------





